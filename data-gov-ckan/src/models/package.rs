/*
 * CKAN API
 *
 * Comprehensive Open Data Knowledge (CKAN) REST API for data management and publishing.  CKAN is a powerful data management system that makes data accessible by providing tools to streamline publishing, sharing, finding and using data. This API provides programmatic access to all CKAN functionality including:  - Dataset (Package) management - create, read, update, delete datasets - Resource management - manage files and data resources within datasets   - Organization and Group management - organize datasets into logical groupings - User management - manage user accounts and permissions - Search functionality - powerful search across all data - Metadata and tagging - rich metadata and taxonomy support - Data validation and quality - ensure data integrity  The API follows REST principles and returns JSON responses. Most endpoints support both GET and POST methods.  ## API Versions  - **API v3** (default): Main action API at `/api/3/action/{action}` - **Utility API v1/v2**: Autocomplete and utility functions at `/api/{version}/util/` - **Legacy API v1**: Basic API information at `/api/1`  ## Authentication  Many API calls require authentication via API key passed as: - HTTP Header: `Authorization: {api_key}` - URL Parameter: `?api_key={api_key}`  - POST Data: `{\"api_key\": \"{api_key}\"}`  ## Error Handling  All API responses include: - `success`: Boolean indicating if the request was successful - `result`: The actual data (on success) or error details (on failure) - `help`: URL to documentation for the action  Error responses include structured error information with error type and detailed messages. 
 *
 * The version of the OpenAPI document: 3.0
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Package {
    /// Unique identifier for the dataset
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// URL-friendly name (slug)
    #[serde(rename = "name")]
    pub name: String,
    /// Human-readable title
    #[serde(rename = "title", skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// Whether dataset is private
    #[serde(rename = "private", skip_serializing_if = "Option::is_none")]
    pub private: Option<bool>,
    /// Name of the dataset author
    #[serde(rename = "author", skip_serializing_if = "Option::is_none")]
    pub author: Option<String>,
    /// Email address of the dataset author
    #[serde(rename = "author_email", skip_serializing_if = "Option::is_none")]
    pub author_email: Option<String>,
    /// Name of the dataset maintainer
    #[serde(rename = "maintainer", skip_serializing_if = "Option::is_none")]
    pub maintainer: Option<String>,
    /// Email address of the dataset maintainer
    #[serde(rename = "maintainer_email", skip_serializing_if = "Option::is_none")]
    pub maintainer_email: Option<String>,
    /// License identifier
    #[serde(rename = "license_id", skip_serializing_if = "Option::is_none")]
    pub license_id: Option<String>,
    /// License title
    #[serde(rename = "license_title", skip_serializing_if = "Option::is_none")]
    pub license_title: Option<String>,
    /// Whether dataset is open
    #[serde(rename = "isopen", skip_serializing_if = "Option::is_none")]
    pub isopen: Option<bool>,
    /// Number of resources
    #[serde(rename = "num_resources", skip_serializing_if = "Option::is_none")]
    pub num_resources: Option<i32>,
    /// Number of tags
    #[serde(rename = "num_tags", skip_serializing_if = "Option::is_none")]
    pub num_tags: Option<i32>,
    /// Dataset description/notes
    #[serde(rename = "notes", skip_serializing_if = "Option::is_none")]
    pub notes: Option<String>,
    /// URL for the dataset source
    #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// Dataset version
    #[serde(rename = "version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// Current state of the dataset
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<State>,
    /// Type of the dataset
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,
    /// ID of the owning organization
    #[serde(rename = "owner_org", skip_serializing_if = "Option::is_none")]
    pub owner_org: Option<String>,
    /// Organization details
    #[serde(rename = "organization", skip_serializing_if = "Option::is_none")]
    pub organization: Option<models::Group>,
    /// ID of the user who created the dataset
    #[serde(rename = "creator_user_id", skip_serializing_if = "Option::is_none")]
    pub creator_user_id: Option<String>,
    /// When the dataset metadata was created
    #[serde(rename = "metadata_created", skip_serializing_if = "Option::is_none")]
    pub metadata_created: Option<String>,
    /// When the dataset metadata was last modified
    #[serde(rename = "metadata_modified", skip_serializing_if = "Option::is_none")]
    pub metadata_modified: Option<String>,
    #[serde(rename = "resources", skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<models::Resource>>,
    #[serde(rename = "tags", skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<models::Tag>>,
    #[serde(rename = "groups", skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<models::Group>>,
    /// Additional metadata key-value pairs
    #[serde(rename = "extras", skip_serializing_if = "Option::is_none")]
    pub extras: Option<Vec<models::Extra>>,
    /// Plugin-specific data (sysadmin only)
    #[serde(rename = "plugin_data", skip_serializing_if = "Option::is_none")]
    pub plugin_data: Option<serde_json::Value>,
}

impl Package {
    pub fn new(name: String) -> Package {
        Package {
            id: None,
            name,
            title: None,
            private: None,
            author: None,
            author_email: None,
            maintainer: None,
            maintainer_email: None,
            license_id: None,
            license_title: None,
            isopen: None,
            num_resources: None,
            num_tags: None,
            notes: None,
            url: None,
            version: None,
            state: None,
            r#type: None,
            owner_org: None,
            organization: None,
            creator_user_id: None,
            metadata_created: None,
            metadata_modified: None,
            resources: None,
            tags: None,
            groups: None,
            extras: None,
            plugin_data: None,
        }
    }
}
/// Current state of the dataset
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum State {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "deleted")]
    Deleted,
    #[serde(rename = "draft")]
    Draft,
}

impl Default for State {
    fn default() -> State {
        Self::Active
    }
}

