/*
 * CKAN API
 *
 * Comprehensive Open Data Knowledge (CKAN) REST API for data management and publishing.  CKAN is a powerful data management system that makes data accessible by providing tools to streamline publishing, sharing, finding and using data. This API provides programmatic access to all CKAN functionality including:  - Dataset (Package) management - create, read, update, delete datasets - Resource management - manage files and data resources within datasets   - Organization and Group management - organize datasets into logical groupings - User management - manage user accounts and permissions - Search functionality - powerful search across all data - Metadata and tagging - rich metadata and taxonomy support - Data validation and quality - ensure data integrity  The API follows REST principles and returns JSON responses. Most endpoints support both GET and POST methods.  ## API Versions  - **API v3** (default): Main action API at `/api/3/action/{action}` - **Utility API v1/v2**: Autocomplete and utility functions at `/api/{version}/util/` - **Legacy API v1**: Basic API information at `/api/1`  ## Authentication  Many API calls require authentication via API key passed as: - HTTP Header: `Authorization: {api_key}` - URL Parameter: `?api_key={api_key}`  - POST Data: `{\"api_key\": \"{api_key}\"}`  ## Error Handling  All API responses include: - `success`: Boolean indicating if the request was successful - `result`: The actual data (on success) or error details (on failure) - `help`: URL to documentation for the action  Error responses include structured error information with error type and detailed messages.
 *
 * The version of the OpenAPI document: 3.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct User {
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// Username (unique identifier)
    #[serde(rename = "name")]
    pub name: String,
    /// Full display name
    #[serde(rename = "fullname", skip_serializing_if = "Option::is_none")]
    pub fullname: Option<String>,
    /// Computed display name
    #[serde(rename = "display_name", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "email", skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    /// User biography/about text
    #[serde(rename = "about", skip_serializing_if = "Option::is_none")]
    pub about: Option<String>,
    #[serde(rename = "created", skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    /// Whether user is a system administrator
    #[serde(rename = "sysadmin", skip_serializing_if = "Option::is_none")]
    pub sysadmin: Option<bool>,
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<State>,
    #[serde(rename = "image_url", skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,
    #[serde(rename = "image_display_url", skip_serializing_if = "Option::is_none")]
    pub image_display_url: Option<String>,
    /// Number of packages created by this user
    #[serde(
        rename = "number_created_packages",
        skip_serializing_if = "Option::is_none"
    )]
    pub number_created_packages: Option<i32>,
}

impl User {
    pub fn new(name: String) -> User {
        User {
            id: None,
            name,
            fullname: None,
            display_name: None,
            email: None,
            about: None,
            created: None,
            sysadmin: None,
            state: None,
            image_url: None,
            image_display_url: None,
            number_created_packages: None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum State {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "deleted")]
    Deleted,
    #[serde(rename = "inactive")]
    Inactive,
}

impl Default for State {
    fn default() -> State {
        Self::Active
    }
}
