use std::sync::Arc;
use serde::{Serialize, Deserialize, de::DeserializeOwned};
use serde_json::Value;
use crate::{apis::{self, Api, configuration::Configuration}, models};

/// # CKA    /// Creates a new CKAN client with the given configuration
    /// 
    /// # Arguments
    /// 
    /// * `configuration` - API configuration including base URL, user agent, and authentication
    /// 
    /// # Examples
    /// 
    /// ```rust
    /// use data_gov_ckan::{CkanClient, apis::configuration::Configuration};
    /// use std::sync::Arc;
    /// 
    /// // Basic client for data.gov
    /// let config = Arc::new(Configuration {
    ///     base_path: "https://catalog.data.gov/api/3".to_string(),
    ///     user_agent: S    /// Get group autocomplete suggestions for filtering and organization
    /// 
    /// Groups in CKAN represent thematic collections of datasets. This endpoint
    /// provides autocomplete functionality for group names and titles.
    /// 
    /// # Arguments
    /// 
    /// * `q` - Partial group name or title to search for (e.g., "agri")
    /// * `limit` - Maximum number of suggestions to return (default: 10)
    /// 
    /// # Returns
    /// 
    /// Returns group suggestions with names, display names, and metadata.
    /// 
    /// # Examples
    /// 
    /// ```rust
    /// # use data_gov_ckan::{CkanClient, apis::configuration::Configuration};
    /// # use std::sync::Arc;
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let client = CkanClient::new(Arc::new(Configuration {
    /// #     base_path: "https://catalog.data.gov/api/3".to_string(),
    /// #     user_agent: Some("test".to_string()),
    /// #     client: reqwest::Client::new(),
    /// #     basic_auth: None, oauth_access_token: None, bearer_access_token: None, api_key: None,
    /// # }));
    /// 
    /// // Find agriculture-related groups
    /// let groups = client.group_autocomplete(Some("agri"), Some(5)).await?;
    /// 
    /// println!("Found {} groups", groups.result.len());
    /// for group in groups.result {
    ///     println!("Group: {} ({})", group.display_name, group.name);
    ///     println!("  Datasets: {}", group.packages.unwrap_or_default());
    /// }
    /// # Ok(())
    /// # }
    /// ```
    /// 
    /// # Common Use Cases
    /// 
    /// ```rust,ignore
    /// // Building category filters for search UI
    /// let science_groups = client.group_autocomplete(Some("science"), Some(10)).await?;
    /// 
    /// // Finding groups for dataset categorization
    /// let energy_groups = client.group_autocomplete(Some("energy"), Some(5)).await?;
    /// ```
    pub async fn group_autocomplete(&self, q: Option<&str>, limit: Option<i32>) -> Result<models::GroupAutocomplete, CkanError> {
        let response = self.api_client.autocomplete_api().group_autocomplete(q, limit).await?;
        Ok(response)
    }

    /// Create a new CKAN client instance
    /// 
    /// Creates a client configured to work with a specific CKAN instance.
    /// For data.gov, use the base URL: `https://catalog.data.gov/api/3`
    /// 
    /// # Arguments
    /// 
    /// * `configuration` - API configuration including base URL, user agent, and credentials
    /// 
    /// # Examples
    /// 
    /// ```rust
    /// # use data_gov_ckan::{CkanClient, apis::configuration::Configuration};
    /// # use std::sync::Arc;
    /// 
    /// // Basic client for read-only operations
    /// let config = Arc::new(Configuration {
    ///     base_path: "https://catalog.data.gov/api/3".to_string(),
    ///     user_agent: Some("my-rust-app/1.0".to_string()),
    ///     client: reqwest::Client::new(),
    ///     basic_auth: None,
    ///     oauth_access_token: None,
    ///     bearer_access_token: None,
    ///     api_key: None,
    /// });
    /// 
    /// let client = CkanClient::new(config);
    /// 
    /// // Client with API key for write operations
    /// let authenticated_config = Arc::new(Configuration {
    ///     base_path: "https://catalog.data.gov/api/3".to_string(),
    ///     user_agent: Some("my-rust-app/1.0".to_string()),
    ///     client: reqwest::Client::new(),
    ///     basic_auth: None,
    ///     oauth_access_token: None,
    ///     bearer_access_token: None,
    ///     api_key: Some("your-api-key-here".to_string()),
    /// });
    /// 
    /// let auth_client = CkanClient::new(authenticated_config);
    /// ```
    pub fn new(configuration: Arc<Configuration>) -> Self {
        Self {
            api_client: apis::ApiClient::new(configuration),
        }
    }
/// 
/// An ergonomic Rust client for interacting with CKAN (Comprehensive Knowledge Archive Network) APIs,
/// specifically designed for data.gov but compatible with any CKAN instance.
/// 
/// ## Features
/// 
/// - **Dataset Management**: Search, retrieve, create, update, and delete datasets (packages)
/// - **Resource Management**: Handle files and data resources within datasets  
/// - **Organization & Groups**: Manage organizational structures and groupings
/// - **User Management**: Handle user accounts and permissions
/// - **Search Functionality**: Powerful search across all data with filtering and faceting
/// - **Autocomplete**: Type-ahead functionality for datasets, tags, users, organizations
/// - **Metadata Support**: Rich metadata and taxonomy support
/// - **Async/Await**: Built on modern async Rust for high performance
/// 
/// ## Usage
/// 
/// ```rust
/// use data_gov_ckan::{CkanClient, apis::configuration::Configuration};
/// use std::sync::Arc;
/// 
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // Create configuration for data.gov
///     let config = Arc::new(Configuration {
///         base_path: "https://catalog.data.gov/api/3".to_string(),
///         user_agent: Some("my-app/1.0".to_string()),
///         client: reqwest::Client::new(),
///         basic_auth: None,
///         oauth_access_token: None,
///         bearer_access_token: None,
///         api_key: None,
///     });
/// 
///     // Create the client
///     let client = CkanClient::new(config);
/// 
///     // Search for datasets
///     let results = client.package_search(
///         Some("electric vehicle"), // query
///         Some("score desc"),        // sort by relevance  
///         Some(10),                  // limit to 10 results
///         None,                      // no offset
///         None,                      // no facet fields
///         None,                      // don't include private
///         None,                      // don't include drafts
///     ).await?;
/// 
///     println!("Found {} datasets", results.count);
///     
///     // Get detailed information about the first dataset
///     if let Some(first_dataset) = results.results.first() {
///         if let Some(id) = &first_dataset.id {
///             let package = client.package_show(id).await?;
///             println!("Dataset: {:?}", package.title);
///         }
///     }
/// 
///     Ok(())
/// }
/// ```
/// 
/// ## Authentication
/// 
/// For read-only operations (searching, getting public datasets), no authentication is required.
/// For write operations, you'll need an API key:
/// 
/// ```rust
/// use data_gov_ckan::apis::configuration::Configuration;
/// use std::sync::Arc;
/// 
/// let config = Arc::new(Configuration {
///     base_path: "https://catalog.data.gov/api/3".to_string(),
///     user_agent: Some("my-app/1.0".to_string()),
///     client: reqwest::Client::new(),
///     basic_auth: None,
///     oauth_access_token: None,
///     bearer_access_token: None,
///     api_key: Some("your-api-key-here".to_string()),
/// });
/// ```
/// 
/// ## Error Handling
/// 
/// All methods return `Result<T, CkanError>` where `CkanError` provides detailed
/// error information:
/// 
/// ```rust
/// use data_gov_ckan::CkanError;
/// 
/// match client.package_show("invalid-id").await {
///     Ok(package) => println!("Got package: {:?}", package.title),
///     Err(CkanError::ActionFailed(msg)) => println!("CKAN error: {}", msg),
///     Err(CkanError::RequestError(e)) => println!("HTTP error: {}", e),
///     Err(CkanError::ParseError(e)) => println!("JSON parsing error: {}", e),
/// }
/// ```
#[derive(Debug)]
pub struct CkanClient {
    api_client: apis::ApiClient,
}

/// # CKAN API Error Types
/// 
/// Represents different types of errors that can occur when interacting with the CKAN API.
/// 
/// ## Error Categories
/// 
/// - **RequestError**: Network-level errors (connection timeouts, DNS issues, etc.)
/// - **ActionFailed**: CKAN-specific errors (dataset not found, permission denied, etc.)
/// - **ParseError**: JSON parsing errors (malformed responses, unexpected structure)
/// 
/// ## Examples
/// 
/// ```rust
/// use data_gov_ckan::CkanError;
/// 
/// match client.package_show("nonexistent").await {
///     Err(CkanError::ActionFailed(msg)) if msg.contains("Not found") => {
///         println!("Dataset doesn't exist");
///     },
///     Err(CkanError::RequestError(_)) => {
///         println!("Network error - check connectivity");
///     },
///     Err(CkanError::ParseError(_)) => {
///         println!("Unexpected response format");
///     },
///     Ok(package) => println!("Found: {:?}", package.title),
/// }
/// ```
#[derive(Debug)]
pub enum CkanError {
    /// HTTP request failed (network issues, timeouts, connectivity problems)
    /// 
    /// This typically indicates:
    /// - Network connectivity issues
    /// - DNS resolution failures  
    /// - Request timeouts
    /// - Invalid URLs
    /// - Server unavailable (5xx errors)
    RequestError(Box<dyn std::error::Error + Send + Sync>),
    
    /// CKAN API returned an error response
    /// 
    /// This indicates the request reached CKAN but the action failed:
    /// - Dataset/resource not found (404)
    /// - Permission denied (403) 
    /// - Invalid parameters (400)
    /// - Authentication required (401)
    /// - CKAN internal errors
    ActionFailed(String),
    
    /// Failed to parse JSON response from CKAN
    /// 
    /// This indicates:
    /// - Malformed JSON in the response
    /// - Unexpected response structure
    /// - Missing required fields
    /// - Type mismatches in the data
    ParseError(serde_json::Error),
}

impl std::fmt::Display for CkanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CkanError::ApiError(msg) => write!(f, "API error: {}", msg),
            CkanError::ParseError(err) => write!(f, "Parse error: {}", err),
            CkanError::ActionFailed(msg) => write!(f, "Action failed: {}", msg),
            CkanError::RequestError(err) => write!(f, "Request error: {}", err),
        }
    }
}

impl std::error::Error for CkanError {}

impl CkanClient {
    /// Create a new CKAN client with the given configuration
    pub fn new(configuration: Arc<Configuration>) -> Self {
        Self {
            api_client: apis::ApiClient::new(configuration),
        }
    }

    /// Execute a generic action and parse the result
    async fn execute_action<T>(&self, action: &str, params: Option<Value>) -> Result<T, CkanError>
    where
        T: DeserializeOwned,
    {
        let action_response = if let Some(params) = params {
            match self.api_client
                .action_apiv3_api()
                .action_action_post(action, Some(params))
                .await
            {
                Ok(response) => response,
                Err(err) => return Err(CkanError::RequestError(Box::new(err))),
            }
        } else {
            match self.api_client
                .action_apiv3_api()
                .action_action_get(action, None)
                .await
            {
                Ok(response) => response,
                Err(err) => return Err(CkanError::RequestError(Box::new(err))),
            }
        };

        if !action_response.success {
            return Err(CkanError::ActionFailed(format!("Action '{}' failed", action)));
        }

        match action_response.result {
            Some(result) => {
                serde_json::from_value(result)
                    .map_err(CkanError::ParseError)
            }
            None => Err(CkanError::ActionFailed("No result in successful response".to_string())),
        }
    }

    // === Dataset (Package) Operations ===

    /// Search for datasets using CKAN's powerful search functionality
    /// 
    /// This method provides access to CKAN's Solr-powered search engine, allowing you to find
    /// datasets using text queries, filtering, sorting, and faceting.
    /// 
    /// # Arguments
    /// 
    /// * `query` - The search query string (e.g., "electric vehicle", "climate data")
    ///             Uses Solr query syntax. If None, returns all datasets (*:*)
    /// * `sort` - Sort order (e.g., "score desc", "metadata_modified desc", "title asc")  
    /// * `rows` - Maximum number of results to return (default: 10, max typically: 1000)
    /// * `start` - Offset for pagination (0-based)
    /// * `facet_field` - Fields to facet on for aggregated counts (e.g., ["tags", "organization"])
    /// * `include_private` - Whether to include private datasets (requires authentication)
    /// * `include_drafts` - Whether to include draft datasets (requires authentication)
    /// 
    /// # Returns
    /// 
    /// Returns a `PackageSearchResult` containing:
    /// - `count`: Total number of matching datasets
    /// - `results`: Array of dataset summaries  
    /// - `facets`: Facet counts if requested
    /// 
    /// # Examples
    /// 
    /// ```rust
    /// # use data_gov_ckan::{CkanClient, apis::configuration::Configuration};
    /// # use std::sync::Arc;
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let client = CkanClient::new(Arc::new(Configuration {
    /// #     base_path: "https://catalog.data.gov/api/3".to_string(),
    /// #     user_agent: Some("test".to_string()),
    /// #     client: reqwest::Client::new(),
    /// #     basic_auth: None, oauth_access_token: None, bearer_access_token: None, api_key: None,
    /// # }));
    /// 
    /// // Simple text search
    /// let results = client.package_search(
    ///     Some("electric vehicle"),  // Find datasets about electric vehicles
    ///     Some("score desc"),        // Sort by relevance
    ///     Some(20),                  // Get up to 20 results
    ///     None, None, None, None
    /// ).await?;
    /// 
    /// println!("Found {} datasets", results.count);
    /// for dataset in results.results {
    ///     if let Some(title) = &dataset.title {
    ///         println!("- {}", title);
    ///     }
    /// }
    /// 
    /// // Search with pagination
    /// let page2 = client.package_search(
    ///     Some("climate"),
    ///     Some("metadata_modified desc"), 
    ///     Some(10),
    ///     Some(10), // Skip first 10 results
    ///     None, None, None
    /// ).await?;
    /// 
    /// // Search with facets for analytics
    /// let faceted = client.package_search(
    ///     Some("data"),
    ///     None,
    ///     Some(0), // Don't need actual results
    ///     None,
    ///     Some(vec!["tags", "organization"]), // Get tag and org counts
    ///     None, None
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    /// 
    /// # CKAN Search Tips
    /// 
    /// - Use `*` as a wildcard: `"climat*"` matches climate, climatic, etc.
    /// - Use quotes for exact phrases: `"sea level rise"`
    /// - Use boolean operators: `"climate AND temperature"`
    /// - Filter by fields: `"tags:climate"` or `"organization:epa"`
    /// - Use date ranges: `"metadata_modified:[2023-01-01T00:00:00Z TO *]"`
    pub async fn package_search(
        &self,
        query: Option<&str>,
        sort: Option<&str>, 
        rows: Option<i32>,
        start: Option<i32>,
        facet_field: Option<Vec<&str>>,
        include_private: Option<bool>,
        include_drafts: Option<bool>,
    ) -> Result<models::PackageSearchResult, CkanError> {
        let mut params = serde_json::Map::new();
        
        if let Some(q) = query {
            params.insert("q".to_string(), Value::String(q.to_string()));
        }
        if let Some(sort) = sort {
            params.insert("sort".to_string(), Value::String(sort.to_string()));
        }
        if let Some(rows) = rows {
            params.insert("rows".to_string(), Value::Number(rows.into()));
        }
        if let Some(start) = start {
            params.insert("start".to_string(), Value::Number(start.into()));
        }
        if let Some(facet_field) = facet_field {
            let facets: Vec<Value> = facet_field.iter().map(|s| Value::String(s.to_string())).collect();
            params.insert("facet.field".to_string(), Value::Array(facets));
        }
        if let Some(include_private) = include_private {
            params.insert("include_private".to_string(), Value::Bool(include_private));
        }
        if let Some(include_drafts) = include_drafts {
            params.insert("include_drafts".to_string(), Value::Bool(include_drafts));
        }

        let params_value = if params.is_empty() {
            None
        } else {
            Some(Value::Object(params))
        };

        self.execute_action("package_search", params_value).await
    }

    /// Get detailed information about a specific dataset
    /// 
    /// Retrieves the complete metadata for a dataset, including all resources,
    /// tags, extras, and organizational information.
    /// 
    /// # Arguments
    /// 
    /// * `id` - The dataset ID (UUID) or name (slug). For data.gov, these look like:
    ///          - ID: `"f9880479-bf5c-477c-ba8e-0651a0e054a5"`  
    ///          - Name: `"electric-vehicle-population-data"`
    /// 
    /// # Returns
    /// 
    /// Returns a complete `Package` object with full metadata including:
    /// - Basic info: title, description, author, license
    /// - Resources: downloadable files and their metadata
    /// - Tags: categorization tags 
    /// - Extras: custom key-value metadata
    /// - Organization: owning organization details
    /// - Temporal info: creation/modification dates
    /// 
    /// # Examples
    /// 
    /// ```rust
    /// # use data_gov_ckan::{CkanClient, apis::configuration::Configuration};
    /// # use std::sync::Arc;
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let client = CkanClient::new(Arc::new(Configuration {
    /// #     base_path: "https://catalog.data.gov/api/3".to_string(),
    /// #     user_agent: Some("test".to_string()),
    /// #     client: reqwest::Client::new(),
    /// #     basic_auth: None, oauth_access_token: None, bearer_access_token: None, api_key: None,
    /// # }));
    /// 
    /// // Get dataset by ID
    /// let dataset = client.package_show("f9880479-bf5c-477c-ba8e-0651a0e054a5").await?;
    /// 
    /// println!("Dataset: {}", dataset.title.unwrap_or("No title".to_string()));
    /// println!("Description: {}", dataset.notes.unwrap_or("No description".to_string()));
    /// 
    /// // Check resources
    /// if let Some(resources) = &dataset.resources {
    ///     println!("Resources:");
    ///     for resource in resources {
    ///         if let (Some(name), Some(format), Some(url)) = (&resource.name, &resource.format, &resource.url) {
    ///             println!("  - {} ({}) - {}", name, format, url);
    ///         }
    ///     }
    /// }
    /// 
    /// // Check tags
    /// if let Some(tags) = &dataset.tags {
    ///     let tag_names: Vec<_> = tags.iter()
    ///         .filter_map(|tag| tag.name.as_ref())
    ///         .collect();
    ///     println!("Tags: {}", tag_names.join(", "));
    /// }
    /// 
    /// // Get dataset by name (slug)
    /// let dataset2 = client.package_show("electric-vehicle-population-data").await?;
    /// # Ok(())
    /// # }
    /// ```
    /// 
    /// # Errors
    /// 
    /// - `CkanError::ActionFailed`: Dataset not found or access denied
    /// - `CkanError::RequestError`: Network or server error
    /// - `CkanError::ParseError`: Invalid response format
    pub async fn package_show(&self, id: &str) -> Result<models::Package, CkanError> {
        let params = serde_json::json!({
            "id": id
        });
        self.execute_action("package_show", Some(params)).await
    }

    /// Create a new dataset
    pub async fn package_create(&self, package: &models::Package) -> Result<models::Package, CkanError> {
        let params = serde_json::to_value(package)
            .map_err(CkanError::ParseError)?;
        self.execute_action("package_create", Some(params)).await
    }

    /// Update an existing dataset
    pub async fn package_update(&self, package: &models::Package) -> Result<models::Package, CkanError> {
        let params = serde_json::to_value(package)
            .map_err(CkanError::ParseError)?;
        self.execute_action("package_update", Some(params)).await
    }

    /// Delete a dataset
    pub async fn package_delete(&self, id: &str) -> Result<models::Package, CkanError> {
        let params = serde_json::json!({
            "id": id
        });
        self.execute_action("package_delete", Some(params)).await
    }

    /// List all datasets
    pub async fn package_list(&self, limit: Option<i32>, offset: Option<i32>) -> Result<Vec<String>, CkanError> {
        let mut params = serde_json::Map::new();
        
        if let Some(limit) = limit {
            params.insert("limit".to_string(), Value::Number(limit.into()));
        }
        if let Some(offset) = offset {
            params.insert("offset".to_string(), Value::Number(offset.into()));
        }

        let params_value = if params.is_empty() {
            None
        } else {
            Some(Value::Object(params))
        };

        self.execute_action("package_list", params_value).await
    }

    // === Organization Operations ===

    /// Get organization by ID or name
    pub async fn organization_show(&self, id: &str, include_datasets: Option<bool>) -> Result<models::Group, CkanError> {
        let mut params = serde_json::Map::new();
        params.insert("id".to_string(), Value::String(id.to_string()));
        
        if let Some(include_datasets) = include_datasets {
            params.insert("include_datasets".to_string(), Value::Bool(include_datasets));
        }

        self.execute_action("organization_show", Some(Value::Object(params))).await
    }

    /// List all organizations
    pub async fn organization_list(&self, all_fields: Option<bool>) -> Result<Vec<models::Group>, CkanError> {
        let mut params = serde_json::Map::new();
        
        if let Some(all_fields) = all_fields {
            params.insert("all_fields".to_string(), Value::Bool(all_fields));
        }

        let params_value = if params.is_empty() {
            None
        } else {
            Some(Value::Object(params))
        };

        self.execute_action("organization_list", params_value).await
    }

    /// Create a new organization
    pub async fn organization_create(&self, organization: &models::Group) -> Result<models::Group, CkanError> {
        let params = serde_json::to_value(organization)
            .map_err(CkanError::ParseError)?;
        self.execute_action("organization_create", Some(params)).await
    }

    // === Group Operations ===

    /// Get group by ID or name
    pub async fn group_show(&self, id: &str, include_datasets: Option<bool>) -> Result<models::Group, CkanError> {
        let mut params = serde_json::Map::new();
        params.insert("id".to_string(), Value::String(id.to_string()));
        
        if let Some(include_datasets) = include_datasets {
            params.insert("include_datasets".to_string(), Value::Bool(include_datasets));
        }

        self.execute_action("group_show", Some(Value::Object(params))).await
    }

    /// List all groups
    pub async fn group_list(&self, all_fields: Option<bool>) -> Result<Vec<models::Group>, CkanError> {
        let mut params = serde_json::Map::new();
        
        if let Some(all_fields) = all_fields {
            params.insert("all_fields".to_string(), Value::Bool(all_fields));
        }

        let params_value = if params.is_empty() {
            None
        } else {
            Some(Value::Object(params))
        };

        self.execute_action("group_list", params_value).await
    }

    /// Create a new group
    pub async fn group_create(&self, group: &models::Group) -> Result<models::Group, CkanError> {
        let params = serde_json::to_value(group)
            .map_err(CkanError::ParseError)?;
        self.execute_action("group_create", Some(params)).await
    }

    // === User Operations ===

    /// Get user by ID or name
    pub async fn user_show(&self, id: &str, include_datasets: Option<bool>) -> Result<models::User, CkanError> {
        let mut params = serde_json::Map::new();
        params.insert("id".to_string(), Value::String(id.to_string()));
        
        if let Some(include_datasets) = include_datasets {
            params.insert("include_datasets".to_string(), Value::Bool(include_datasets));
        }

        self.execute_action("user_show", Some(Value::Object(params))).await
    }

    /// List all users
    pub async fn user_list(&self) -> Result<Vec<models::User>, CkanError> {
        self.execute_action("user_list", None).await
    }

    /// Create a new user
    pub async fn user_create(&self, user: &models::User) -> Result<models::User, CkanError> {
        let params = serde_json::to_value(user)
            .map_err(CkanError::ParseError)?;
        self.execute_action("user_create", Some(params)).await
    }

    // === Resource Operations ===

    /// Get resource by ID
    pub async fn resource_show(&self, id: &str) -> Result<models::Resource, CkanError> {
        let params = serde_json::json!({
            "id": id
        });
        self.execute_action("resource_show", Some(params)).await
    }

    /// Create a new resource
    pub async fn resource_create(&self, resource: &models::Resource) -> Result<models::Resource, CkanError> {
        let params = serde_json::to_value(resource)
            .map_err(CkanError::ParseError)?;
        self.execute_action("resource_create", Some(params)).await
    }

    /// Update an existing resource
    pub async fn resource_update(&self, resource: &models::Resource) -> Result<models::Resource, CkanError> {
        let params = serde_json::to_value(resource)
            .map_err(CkanError::ParseError)?;
        self.execute_action("resource_update", Some(params)).await
    }

    // === Site Operations ===

    /// Get site status information
    pub async fn status_show(&self) -> Result<models::StatusInfo, CkanError> {
        self.execute_action("status_show", None).await
    }

    // === Autocomplete Operations (using the existing API) ===

    /// Get dataset autocomplete suggestions for type-ahead functionality
    /// 
    /// Provides quick dataset name/title suggestions as the user types, perfect for
    /// implementing search boxes with autocomplete dropdowns.
    /// 
    /// # Arguments
    /// 
    /// * `incomplete` - Partial dataset name or title to search for (e.g., "climat")
    /// * `limit` - Maximum number of suggestions to return (default: 10, reasonable max: 20)
    /// 
    /// # Returns
    /// 
    /// Returns suggestions containing dataset names and titles that match the input.
    /// 
    /// # Examples
    /// 
    /// ```rust
    /// # use data_gov_ckan::{CkanClient, apis::configuration::Configuration};
    /// # use std::sync::Arc;
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let client = CkanClient::new(Arc::new(Configuration {
    /// #     base_path: "https://catalog.data.gov/api/3".to_string(),
    /// #     user_agent: Some("test".to_string()),
    /// #     client: reqwest::Client::new(),
    /// #     basic_auth: None, oauth_access_token: None, bearer_access_token: None, api_key: None,
    /// # }));
    /// 
    /// // Get suggestions as user types "elect"
    /// let suggestions = client.dataset_autocomplete(Some("elect"), Some(5)).await?;
    /// 
    /// if let Some(result_set) = suggestions.result_set {
    ///     for suggestion in result_set {
    ///         println!("Dataset: {}", suggestion.name.unwrap_or_default());
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    /// 
    /// # UI Integration
    /// 
    /// This is designed for real-time search suggestions:
    /// 
    /// ```rust,ignore
    /// // In your web frontend or CLI app
    /// async fn on_search_input_change(input: &str, client: &CkanClient) {
    ///     if input.len() >= 2 { // Start suggesting after 2+ characters
    ///         let suggestions = client.dataset_autocomplete(Some(input), Some(10)).await?;
    ///         // Display suggestions in dropdown/list
    ///         show_suggestions(suggestions);
    ///     }
    /// }
    /// ```
    pub async fn dataset_autocomplete(&self, incomplete: Option<&str>, limit: Option<i32>) -> Result<models::UtilDatasetAutocompleteGet200Response, CkanError> {
        match self.api_client.autocomplete_api().util_dataset_autocomplete_get(incomplete, limit).await {
            Ok(response) => Ok(response),
            Err(err) => Err(CkanError::RequestError(Box::new(err))),
        }
    }

    /// Get tag autocomplete suggestions
    pub async fn tag_autocomplete(&self, incomplete: Option<&str>, limit: Option<i32>, vocabulary_id: Option<&str>) -> Result<models::UtilTagAutocompleteGet200Response, CkanError> {
        match self.api_client.autocomplete_api().util_tag_autocomplete_get(incomplete, limit, vocabulary_id).await {
            Ok(response) => Ok(response),
            Err(err) => Err(CkanError::RequestError(Box::new(err))),
        }
    }

    /// Get user autocomplete suggestions
    pub async fn user_autocomplete(&self, q: Option<&str>, limit: Option<i32>, ignore_self: Option<bool>) -> Result<Vec<models::UserAutocomplete>, CkanError> {
        match self.api_client.autocomplete_api().util_user_autocomplete_get(q, limit, ignore_self).await {
            Ok(response) => Ok(response),
            Err(err) => Err(CkanError::RequestError(Box::new(err))),
        }
    }

    /// Get group autocomplete suggestions
    pub async fn group_autocomplete(&self, q: Option<&str>, limit: Option<i32>) -> Result<Vec<models::GroupAutocomplete>, CkanError> {
        match self.api_client.autocomplete_api().util_group_autocomplete_get(q, limit).await {
            Ok(response) => Ok(response),
            Err(err) => Err(CkanError::RequestError(Box::new(err))),
        }
    }

    /// Get organization autocomplete suggestions
    pub async fn organization_autocomplete(&self, q: Option<&str>, limit: Option<i32>) -> Result<Vec<models::OrganizationAutocomplete>, CkanError> {
        match self.api_client.autocomplete_api().util_organization_autocomplete_get(q, limit).await {
            Ok(response) => Ok(response),
            Err(err) => Err(CkanError::RequestError(Box::new(err))),
        }
    }

    /// Get resource format autocomplete suggestions
    pub async fn resource_format_autocomplete(&self, incomplete: Option<&str>, limit: Option<i32>) -> Result<models::UtilResourceFormatAutocompleteGet200Response, CkanError> {
        match self.api_client.autocomplete_api().util_resource_format_autocomplete_get(incomplete, limit).await {
            Ok(response) => Ok(response),
            Err(err) => Err(CkanError::RequestError(Box::new(err))),
        }
    }
}